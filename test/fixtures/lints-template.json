{"lints":{"lint":[{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\elapsed-time-lib.xqy", "rule":[{"name":"declare function return type", "level":"warn", "occurrences":"1", "source":["function elapsedtime:get-time() {\n  $elapsed-time-array\n}"]}]},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import-lib-old-version.xqy", "rule":[{"name":"avoid using xdmp:eval and xdmp:value", "level":"warn", "occurrences":"3", "source":["function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}"]},{"name":"declare function return type", "level":"warn", "occurrences":"5", "source":["function get-template($template-name as xs:string) {\n   \/import:template[import:name = $template-name]\n}","function get-model-templates($model-name) {\n   \/import:template[import:model\/@name = $model-name]\n}","function convert-xlsx(\n  $doc as item(),\n  $template as element(import:template)\n) {\n   convert-xlsx( $doc,\n    $template,\n    $default-options\n   )\n}","function import:convert-xlsx(\n   $doc as item(),\n   $template as element(import:template),\n   $options as element(import:options)\n) {\n    let $excel-map := excel:load($doc)\n    let $ss        := excel:shared-strings-map($excel-map)\n    let $load-map  := map:map()\n    let $column-header := $options\/import:column-headers = fn:true()\n    let $start-row  :=\n        if($column-header = fn:true()) then 2 else 1\n    let $sheets :=  \n       for $sheet in excel:get-sheet-names($excel-map) \n       let $sheet-data   := excel:get-sheet-by-name($excel-map,$sheet)\n       let $column-names := excel:get-sheet-column-names-map($sheet-data,$ss)\n       let $columns := \n                  for $col at $cpos in $column-names\n                  return <column id=\"{$col}\" index=\"{$cpos}\"  xmlns=\"http:\/\/marklogic.com\/import\"><\/column>\n       let $rows := \n          for $row at $rpos in fn:subsequence(excel:get-sheet-rows($sheet-data),$start-row)\n          return\n            <row index=\"{$rpos}\"  xmlns=\"http:\/\/marklogic.com\/import\">{\n              excel:map-row-cells-to-elements-map($row, $column-names, $ss)\n            }<\/row>\n             \n       return <sheet name=\"{$sheet}\"  xmlns=\"http:\/\/marklogic.com\/import\">\n                  <columns>{$columns}<\/columns>\n                  <rows>{$rows}<\/rows>\n              <\/sheet>\nreturn  \n   <data xmlns=\"http:\/\/marklogic.com\/import\">{\n    $sheets\n   }<\/data>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}"]},{"name":"declare function parameter types", "level":"warn", "occurrences":"1", "source":["function get-model-templates($model-name) {\n   \/import:template[import:model\/@name = $model-name]\n}"]},{"name":"avoid long functions", "level":"warn", "occurrences":"2", "source":["function import:convert-xlsx(\n   $doc as item(),\n   $template as element(import:template),\n   $options as element(import:options)\n) {\n    let $excel-map := excel:load($doc)\n    let $ss        := excel:shared-strings-map($excel-map)\n    let $load-map  := map:map()\n    let $column-header := $options\/import:column-headers = fn:true()\n    let $start-row  :=\n        if($column-header = fn:true()) then 2 else 1\n    let $sheets :=  \n       for $sheet in excel:get-sheet-names($excel-map) \n       let $sheet-data   := excel:get-sheet-by-name($excel-map,$sheet)\n       let $column-names := excel:get-sheet-column-names-map($sheet-data,$ss)\n       let $columns := \n                  for $col at $cpos in $column-names\n                  return <column id=\"{$col}\" index=\"{$cpos}\"  xmlns=\"http:\/\/marklogic.com\/import\"><\/column>\n       let $rows := \n          for $row at $rpos in fn:subsequence(excel:get-sheet-rows($sheet-data),$start-row)\n          return\n            <row index=\"{$rpos}\"  xmlns=\"http:\/\/marklogic.com\/import\">{\n              excel:map-row-cells-to-elements-map($row, $column-names, $ss)\n            }<\/row>\n             \n       return <sheet name=\"{$sheet}\"  xmlns=\"http:\/\/marklogic.com\/import\">\n                  <columns>{$columns}<\/columns>\n                  <rows>{$rows}<\/rows>\n              <\/sheet>\nreturn  \n   <data xmlns=\"http:\/\/marklogic.com\/import\">{\n    $sheets\n   }<\/data>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}"]},{"name":"avoid nesting FLWOR expressions more than one level deep", "level":"warn", "occurrences":"6", "source":["function import:convert-xlsx(\n   $doc as item(),\n   $template as element(import:template),\n   $options as element(import:options)\n) {\n    let $excel-map := excel:load($doc)\n    let $ss        := excel:shared-strings-map($excel-map)\n    let $load-map  := map:map()\n    let $column-header := $options\/import:column-headers = fn:true()\n    let $start-row  :=\n        if($column-header = fn:true()) then 2 else 1\n    let $sheets :=  \n       for $sheet in excel:get-sheet-names($excel-map) \n       let $sheet-data   := excel:get-sheet-by-name($excel-map,$sheet)\n       let $column-names := excel:get-sheet-column-names-map($sheet-data,$ss)\n       let $columns := \n                  for $col at $cpos in $column-names\n                  return <column id=\"{$col}\" index=\"{$cpos}\"  xmlns=\"http:\/\/marklogic.com\/import\"><\/column>\n       let $rows := \n          for $row at $rpos in fn:subsequence(excel:get-sheet-rows($sheet-data),$start-row)\n          return\n            <row index=\"{$rpos}\"  xmlns=\"http:\/\/marklogic.com\/import\">{\n              excel:map-row-cells-to-elements-map($row, $column-names, $ss)\n            }<\/row>\n             \n       return <sheet name=\"{$sheet}\"  xmlns=\"http:\/\/marklogic.com\/import\">\n                  <columns>{$columns}<\/columns>\n                  <rows>{$rows}<\/rows>\n              <\/sheet>\nreturn  \n   <data xmlns=\"http:\/\/marklogic.com\/import\">{\n    $sheets\n   }<\/data>\n}","function import:convert-xlsx(\n   $doc as item(),\n   $template as element(import:template),\n   $options as element(import:options)\n) {\n    let $excel-map := excel:load($doc)\n    let $ss        := excel:shared-strings-map($excel-map)\n    let $load-map  := map:map()\n    let $column-header := $options\/import:column-headers = fn:true()\n    let $start-row  :=\n        if($column-header = fn:true()) then 2 else 1\n    let $sheets :=  \n       for $sheet in excel:get-sheet-names($excel-map) \n       let $sheet-data   := excel:get-sheet-by-name($excel-map,$sheet)\n       let $column-names := excel:get-sheet-column-names-map($sheet-data,$ss)\n       let $columns := \n                  for $col at $cpos in $column-names\n                  return <column id=\"{$col}\" index=\"{$cpos}\"  xmlns=\"http:\/\/marklogic.com\/import\"><\/column>\n       let $rows := \n          for $row at $rpos in fn:subsequence(excel:get-sheet-rows($sheet-data),$start-row)\n          return\n            <row index=\"{$rpos}\"  xmlns=\"http:\/\/marklogic.com\/import\">{\n              excel:map-row-cells-to-elements-map($row, $column-names, $ss)\n            }<\/row>\n             \n       return <sheet name=\"{$sheet}\"  xmlns=\"http:\/\/marklogic.com\/import\">\n                  <columns>{$columns}<\/columns>\n                  <rows>{$rows}<\/rows>\n              <\/sheet>\nreturn  \n   <data xmlns=\"http:\/\/marklogic.com\/import\">{\n    $sheets\n   }<\/data>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}","function import-xlsx-data(\n  $data as element(import:data),\n  $template as element(import:template)\n) {\n        let $model-name := xs:string($template\/import:model\/@name)\n        let $model := domain:get-model($model-name)\n        let $_ := ( (:Sanity Checks:)\n           if($model-name and $model) then () else fn:error(xs:QName(\"MODEL-NOT-EXISTS\"),\"The model does not exist\",$model-name)\n        )          \n        let $null-values := $template\/import:null-value  \n        let $constraint-qname :=\n           let $constraint:= $template\/import:constraint\n           let $qname := fn:QName($constraint\/import:name\/@namespace, $constraint\/import:name\/@local-name)\n           return\n             $qname\n        let $rmap-func-string := \n              \"function($row) {\" || \n              \"let $column := \n                function($index) {\n                  let $value := \n                        if($index castable as xs:integer) \n                        then fn:string(($row\/field)[@col = $index])\n                        else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then '' else $value,'')[1]\n                }\n              let $rmap := map:map()\n              let $_ := (\n              \" ||\n              fn:string-join(\n              for $mapping in $template\/import:mapping return \"map:put($rmap,'\" ||$mapping\/@to || \"',\" || $mapping\/@from || \")\"\n              ,\",\")\n              || \") return $rmap }\" \n        let $rmap-func := xdmp:value($rmap-func-string)\n       \n        let $updates :=  \n          for $row  at $rpos in fn:subsequence($data\/import:sheet\/import:rows\/import:row,1)\n          let $rmap := $rmap-func($row)\n          let $column := \n             function($index) {\n                  let $value := \n                  if($index castable as xs:integer) \n                  then fn:string(($row\/field)[@col = $index])\n                  else fn:string(($row\/field)[@columnName = $index])\n                  return \n                    (if($value = $null-values) then \"\" else $value,\"\")[1]\n             }\n          let $constraint-value := xdmp:value($template\/import:constraint\/import:value)\n          let $constraint-params := map:map()\n\n          let $key-query := cts:and-query((cts:element-value-query($constraint-qname,$constraint-value)))\n          let $_ := map:put($constraint-params,\"_query\",$key-query)\n          let $exists := model:exists($model,$constraint-params)\n          return try {\n             if(map:count($rmap) = 0) then fn:error(xs:QName(\"NO-COLUMNS\"),\"There is column data \",()) else (),\n             if($exists) \n             then \n               let $current := (model:filter($model,$constraint-params))[1]\n               let $identity-field := domain:get-model-identity-field($model)\n               let $identity-value := domain:get-field-value($identity-field,$current)  \n               let $_ := map:put($rmap,$identity-field\/@name,$identity-value)\n               return (\n                 let $record := model:update($model,$rmap,(),fn:true())\n                 return \n                    <rowStatus pos=\"{$rpos}\" status=\"Updated\" id=\"{$record\/*:uuid}\" xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n             else (\n              let $record := model:create($model,$rmap,(),xdmp:eval(\"xdmp:default-permissions()\",(),<options xmlns=\"xdmp:eval\"><user-id>{xdmp:user(\"swatadmin\")}<\/user-id><\/options>))\n              return \n                 <rowStatus pos=\"{$rpos}\" status=\"Created\" id=\"{$record\/*:uuid}\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\" \/>\n              )\n              } catch * {\n              <rowStatus pos=\"{$rpos}\" status=\"Error\"  xmlns=\"http:\/\/marklogic.com\/import\" key=\"{$constraint-value}\">\n                <message>{\"Could not import row(\" || fn:string($rpos) || \")\" }<\/message>\n                <innerException>{$err:value}<\/innerException>\n              <\/rowStatus> }\n        return \n           <import-log xmlns=\"http:\/\/marklogic.com\/import\" elapsed=\"{xdmp:elapsed-time()}\">\n           {$updates}\n           <\/import-log>\n}"]}]},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import-lib.xqy", "rule":[{"name":"avoid using xdmp:eval and xdmp:value", "level":"warn", "occurrences":"1", "source":["function entity-exists(\n  $uri as xs:string, \n  $node as item(), \n  $template as element(template:template),\n  $mappings as element(import:mappings)\n) as xs:boolean {\n  let $mapping-key := $template\/template:mappings\/template:mapping[template:source\/@key = \"true\"]\n  let $query := \n    if ($mapping-key) then\n      let $property-group-type-name := get-property-group-type-name($mapping-key\/template:destination\/template:propertyGroup\/fn:string(.), $mappings)\n      let $property-type-name := get-property-type-name($mapping-key\/template:destination\/template:property\/fn:string(.), $mappings)\n      let $namespace-uri := get-default-namespace($template, $mappings)\n      let $path := \n                \"$node\/*\" || \n                \"[name()='\" || $property-group-type-name || \"']\/*\" || \n                \"[name()='\" || $property-type-name || \"']\/\" ||\n                \"fn:string(.)\"\n      let $value := xdmp:value($path)\n      return\n      xdmp:exists(\n        cts:search(\n          doc(), \n          cts:element-value-query(\n            fn:QName($namespace-uri, $property-type-name), \n            $value\n          )\n        )\n      )\n    else\n      ()\n  return \n    fn:doc-available($uri) or $query \n}"]},{"name":"declare function return type", "level":"warn", "occurrences":"2", "source":["function update-template(\n  $template as element(template:template),\n  $mappings as element(import:mappings)?\n) {\n  template:update-template($template, get-mappings($mappings))\n}","function apply-column-transformation($column-value as item(), $fail-safe as xs:boolean?, $fn as function(*)) {\n  try {\n\t\txdmp:apply($fn, $column-value)\n\t} catch * {\n    if ($fail-safe) then\n      $column-value\n    else\n      ()\n\t}\n}"]},{"name":"avoid declaring functions with more than 4 parameters", "level":"info", "occurrences":"5", "source":["function consolidate-dataset(\n  $batch as xs:string,\n  $array as json:array,\n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as map:map? {\n  let $dataset := map:new()\n  let $original-dataset-uuid := get-uuid(()) (:get-original-dataset-uri:)\n  let $original-dataset := \n  <dataEntity xmlns=\"http:\/\/marklogic.com\/import\">\n    <uuid>{$original-dataset-uuid}<\/uuid>\n    <batch>{$batch}<\/batch>\n    <columns>\n    {\n      for $source in $template\/template:mappings\/template:mapping\/template:source\/fn:string(.)\n        return <column>{$source}<\/column>\n    }\n    <\/columns>\n    <rows>\n    {\n      for $item at $row-num in json:array-values($array)\n        return (\n          <row id=\"{$row-num}\">\n          {\n            for $key in map:keys($item)\n              return <col>{map:get($item, $key)}<\/col>\n          }\n          <\/row>,\n          populate-map($batch, $dataset, get-item-key($item, $template), $item, $template, $mappings, $options)\n        )\n    }\n    <\/rows>\n  <\/dataEntity>\n  let $_ := xdmp:document-insert(get-original-dataset-uri($original-dataset-uuid), $original-dataset, xdmp:default-permissions(), get-collection($options))\n  let $_ := add-cache-entry($DUPLICATED-KEY, (json:array-size($array) - map:count($dataset)))\n  return $dataset\n}","function populate-map(\n  $batch as xs:string,\n  $dataset as map:map,\n  $key as xs:string?,\n  $item as map:map,\n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as empty-sequence() {\n  let $entity := get-entity-by-row($batch, apply-transformation($item, $template, $mappings, $options), $template, $mappings)\n  return map:put($dataset, if (fn:exists($key)) then $key else $entity[1], $entity[2])\n}","function import-dataset(\n  $batch as xs:string,\n  $dataset as map:map, \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element(import:audit) {\n  let $start := xdmp:elapsed-time()\n  let $user := xdmp:get-current-user()\n  let $ids := for $key in map:keys($dataset)\n    return import-dataset-by-row($batch, $key, map:get($dataset, $key), $template, $mappings, $options)\n  return \n  <audit xmlns=\"http:\/\/marklogic.com\/import\">\n    <uuid>{ sem:uuid-string() }<\/uuid>\n    <timestamp>{ fn:current-dateTime() }<\/timestamp>\n    <user>{ $user }<\/user>\n    <batch>{ $batch }<\/batch>\n    <updated>{ fn:count($ids[filter-by-operation(., \"update\")]) }<\/updated>\n    <added>{ fn:count($ids[filter-by-operation(., \"add\")]) }<\/added>\n    <failed>{ fn:count($ids[filter-by-operation(., \"fail\")]) }<\/failed>\n    <duplicated>{get-cache-entry($DUPLICATED-KEY)}<\/duplicated>\n    <template>{ $template\/template:id\/fn:string(.) }<\/template>\n    <duration>{ (xdmp:elapsed-time() - $start) div xs:dayTimeDuration('PT1S') }<\/duration>\n  <\/audit>\n}","function import-datasource(\n  $batch as xs:string,\n  $dataset as map:map, \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element(import:audit) {\n  let $audit := import-dataset($batch, $dataset, $template, $mappings, $options)\n  return\n  (\n    xdmp:document-insert(get-audit-uri($batch), $audit, xdmp:default-permissions(), get-collection($options)),\n    clear-cache-entry(),\n    $audit\n  )\n}","function import-dataset-by-row(\n  $batch as xs:string,\n  $key as xs:string,\n  $node as item(), \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element() {\n  let $uri := get-entity-uri($key, $template, $mappings)\n  let $item :=\n  try {\n    let $operation :=\n      if (entity-exists($uri, $node, $template, $mappings)) then\n        let $_ := xdmp:node-replace(fn:doc($uri)\/node(), $node)\n        return \"update\"\n      else\n        let $_ := xdmp:document-insert($uri, $node, xdmp:default-permissions(), get-collection($options))\n        return \"add\"\n    return \n      <item>\n        <id>{$key}<\/id>\n        <operation>{$operation}<\/operation>\n      <\/item>\n     \n   } catch * {\n    let $_ := xdmp:log(\"Fail to import \" || $key, \"error\")\n    let $_ := xdmp:log($node, \"error\")\n    let $_ := xdmp:log(\"Error code [\" || $err:code || \"] - module [\" || $err:module || \"] - line [\" || $err:line-number || \"] - column [\" || $err:column-number || \"]\", \"error\")\n    return\n      <item>\n        <id>{$key}<\/id>\n        <operation>fail<\/operation>\n      <\/item>\n   }\n   return $item\n}"]},{"name":"avoid long functions", "level":"warn", "occurrences":"4", "source":["function consolidate-dataset(\n  $batch as xs:string,\n  $array as json:array,\n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as map:map? {\n  let $dataset := map:new()\n  let $original-dataset-uuid := get-uuid(()) (:get-original-dataset-uri:)\n  let $original-dataset := \n  <dataEntity xmlns=\"http:\/\/marklogic.com\/import\">\n    <uuid>{$original-dataset-uuid}<\/uuid>\n    <batch>{$batch}<\/batch>\n    <columns>\n    {\n      for $source in $template\/template:mappings\/template:mapping\/template:source\/fn:string(.)\n        return <column>{$source}<\/column>\n    }\n    <\/columns>\n    <rows>\n    {\n      for $item at $row-num in json:array-values($array)\n        return (\n          <row id=\"{$row-num}\">\n          {\n            for $key in map:keys($item)\n              return <col>{map:get($item, $key)}<\/col>\n          }\n          <\/row>,\n          populate-map($batch, $dataset, get-item-key($item, $template), $item, $template, $mappings, $options)\n        )\n    }\n    <\/rows>\n  <\/dataEntity>\n  let $_ := xdmp:document-insert(get-original-dataset-uri($original-dataset-uuid), $original-dataset, xdmp:default-permissions(), get-collection($options))\n  let $_ := add-cache-entry($DUPLICATED-KEY, (json:array-size($array) - map:count($dataset)))\n  return $dataset\n}","function import-dataset(\n  $batch as xs:string,\n  $dataset as map:map, \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element(import:audit) {\n  let $start := xdmp:elapsed-time()\n  let $user := xdmp:get-current-user()\n  let $ids := for $key in map:keys($dataset)\n    return import-dataset-by-row($batch, $key, map:get($dataset, $key), $template, $mappings, $options)\n  return \n  <audit xmlns=\"http:\/\/marklogic.com\/import\">\n    <uuid>{ sem:uuid-string() }<\/uuid>\n    <timestamp>{ fn:current-dateTime() }<\/timestamp>\n    <user>{ $user }<\/user>\n    <batch>{ $batch }<\/batch>\n    <updated>{ fn:count($ids[filter-by-operation(., \"update\")]) }<\/updated>\n    <added>{ fn:count($ids[filter-by-operation(., \"add\")]) }<\/added>\n    <failed>{ fn:count($ids[filter-by-operation(., \"fail\")]) }<\/failed>\n    <duplicated>{get-cache-entry($DUPLICATED-KEY)}<\/duplicated>\n    <template>{ $template\/template:id\/fn:string(.) }<\/template>\n    <duration>{ (xdmp:elapsed-time() - $start) div xs:dayTimeDuration('PT1S') }<\/duration>\n  <\/audit>\n}","function import-dataset-by-row(\n  $batch as xs:string,\n  $key as xs:string,\n  $node as item(), \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element() {\n  let $uri := get-entity-uri($key, $template, $mappings)\n  let $item :=\n  try {\n    let $operation :=\n      if (entity-exists($uri, $node, $template, $mappings)) then\n        let $_ := xdmp:node-replace(fn:doc($uri)\/node(), $node)\n        return \"update\"\n      else\n        let $_ := xdmp:document-insert($uri, $node, xdmp:default-permissions(), get-collection($options))\n        return \"add\"\n    return \n      <item>\n        <id>{$key}<\/id>\n        <operation>{$operation}<\/operation>\n      <\/item>\n     \n   } catch * {\n    let $_ := xdmp:log(\"Fail to import \" || $key, \"error\")\n    let $_ := xdmp:log($node, \"error\")\n    let $_ := xdmp:log(\"Error code [\" || $err:code || \"] - module [\" || $err:module || \"] - line [\" || $err:line-number || \"] - column [\" || $err:column-number || \"]\", \"error\")\n    return\n      <item>\n        <id>{$key}<\/id>\n        <operation>fail<\/operation>\n      <\/item>\n   }\n   return $item\n}","function entity-exists(\n  $uri as xs:string, \n  $node as item(), \n  $template as element(template:template),\n  $mappings as element(import:mappings)\n) as xs:boolean {\n  let $mapping-key := $template\/template:mappings\/template:mapping[template:source\/@key = \"true\"]\n  let $query := \n    if ($mapping-key) then\n      let $property-group-type-name := get-property-group-type-name($mapping-key\/template:destination\/template:propertyGroup\/fn:string(.), $mappings)\n      let $property-type-name := get-property-type-name($mapping-key\/template:destination\/template:property\/fn:string(.), $mappings)\n      let $namespace-uri := get-default-namespace($template, $mappings)\n      let $path := \n                \"$node\/*\" || \n                \"[name()='\" || $property-group-type-name || \"']\/*\" || \n                \"[name()='\" || $property-type-name || \"']\/\" ||\n                \"fn:string(.)\"\n      let $value := xdmp:value($path)\n      return\n      xdmp:exists(\n        cts:search(\n          doc(), \n          cts:element-value-query(\n            fn:QName($namespace-uri, $property-type-name), \n            $value\n          )\n        )\n      )\n    else\n      ()\n  return \n    fn:doc-available($uri) or $query \n}"]},{"name":"avoid nesting FLWOR expressions more than one level deep", "level":"warn", "occurrences":"4", "source":["function consolidate-dataset(\n  $batch as xs:string,\n  $array as json:array,\n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as map:map? {\n  let $dataset := map:new()\n  let $original-dataset-uuid := get-uuid(()) (:get-original-dataset-uri:)\n  let $original-dataset := \n  <dataEntity xmlns=\"http:\/\/marklogic.com\/import\">\n    <uuid>{$original-dataset-uuid}<\/uuid>\n    <batch>{$batch}<\/batch>\n    <columns>\n    {\n      for $source in $template\/template:mappings\/template:mapping\/template:source\/fn:string(.)\n        return <column>{$source}<\/column>\n    }\n    <\/columns>\n    <rows>\n    {\n      for $item at $row-num in json:array-values($array)\n        return (\n          <row id=\"{$row-num}\">\n          {\n            for $key in map:keys($item)\n              return <col>{map:get($item, $key)}<\/col>\n          }\n          <\/row>,\n          populate-map($batch, $dataset, get-item-key($item, $template), $item, $template, $mappings, $options)\n        )\n    }\n    <\/rows>\n  <\/dataEntity>\n  let $_ := xdmp:document-insert(get-original-dataset-uri($original-dataset-uuid), $original-dataset, xdmp:default-permissions(), get-collection($options))\n  let $_ := add-cache-entry($DUPLICATED-KEY, (json:array-size($array) - map:count($dataset)))\n  return $dataset\n}","function import-dataset-by-row(\n  $batch as xs:string,\n  $key as xs:string,\n  $node as item(), \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element() {\n  let $uri := get-entity-uri($key, $template, $mappings)\n  let $item :=\n  try {\n    let $operation :=\n      if (entity-exists($uri, $node, $template, $mappings)) then\n        let $_ := xdmp:node-replace(fn:doc($uri)\/node(), $node)\n        return \"update\"\n      else\n        let $_ := xdmp:document-insert($uri, $node, xdmp:default-permissions(), get-collection($options))\n        return \"add\"\n    return \n      <item>\n        <id>{$key}<\/id>\n        <operation>{$operation}<\/operation>\n      <\/item>\n     \n   } catch * {\n    let $_ := xdmp:log(\"Fail to import \" || $key, \"error\")\n    let $_ := xdmp:log($node, \"error\")\n    let $_ := xdmp:log(\"Error code [\" || $err:code || \"] - module [\" || $err:module || \"] - line [\" || $err:line-number || \"] - column [\" || $err:column-number || \"]\", \"error\")\n    return\n      <item>\n        <id>{$key}<\/id>\n        <operation>fail<\/operation>\n      <\/item>\n   }\n   return $item\n}","function import-dataset-by-row(\n  $batch as xs:string,\n  $key as xs:string,\n  $node as item(), \n  $template as element(template:template),\n  $mappings as element(import:mappings),\n  $options as element(import:options)\n) as element() {\n  let $uri := get-entity-uri($key, $template, $mappings)\n  let $item :=\n  try {\n    let $operation :=\n      if (entity-exists($uri, $node, $template, $mappings)) then\n        let $_ := xdmp:node-replace(fn:doc($uri)\/node(), $node)\n        return \"update\"\n      else\n        let $_ := xdmp:document-insert($uri, $node, xdmp:default-permissions(), get-collection($options))\n        return \"add\"\n    return \n      <item>\n        <id>{$key}<\/id>\n        <operation>{$operation}<\/operation>\n      <\/item>\n     \n   } catch * {\n    let $_ := xdmp:log(\"Fail to import \" || $key, \"error\")\n    let $_ := xdmp:log($node, \"error\")\n    let $_ := xdmp:log(\"Error code [\" || $err:code || \"] - module [\" || $err:module || \"] - line [\" || $err:line-number || \"] - column [\" || $err:column-number || \"]\", \"error\")\n    return\n      <item>\n        <id>{$key}<\/id>\n        <operation>fail<\/operation>\n      <\/item>\n   }\n   return $item\n}","function get-entity-by-row(\n  $batch as xs:string,\n  $row as map:map, \n  $template as element(template:template),\n  $mappings as element(import:mappings)\n) as item()* {\n  let $id := get-uuid($row)\n  let $row-elt :=\n  element {get-root-qname($template, $mappings)} {\n    attribute id {$id},\n    attribute batch {$batch},\n    for $property-group in get-property-groups($template)\n      return\n      element {get-property-group-qname($property-group, $template, $mappings)} {\n        for $mapping in $template\/template:mappings\/template:mapping[template:destination\/template:propertyGroup\/fn:string(.) = $property-group]\n          let $column-name := $mapping\/template:source\/fn:string(.)\n          let $elt := element {get-property-qname($column-name, $template, $mappings)} {\n            map:get($row, $column-name)\n          }\n          return $elt\n      }\n    }\n   return ( $id, $row-elt )\n}"]}]},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import-template-lib.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 13, column 1\n...declare private function get-tem..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\module-loader-lib.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 11, column 1\n...declare private variable $USE-MO..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\string-lib.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 46, column 1\n...declare private function common-..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import\\plugins\\excel-lib.xqy", "rule":[{"name":"declare function return type", "level":"warn", "occurrences":"7", "source":["function excel:get-number($string as xs:string){\n    if ($string castable as xs:float) then\n         xs:float($string) cast as xs:integer\n    else ()\n}","function excel:load($excel){\n    let $excelmap := map:map()\n    \n\tlet $parts := ooxml:package-parts($excel)\n\tlet $_ :=\n\t    for $uri at $pos in ooxml:package-uris($excel)\n\t        let $content :=  fn:subsequence($parts,$pos,1)\n    \t    return\n    \t        if (fn:contains($uri,'.xml'))\n    \t        then (map:put($excelmap,$uri,$content))\n    \t        else ()\n\n     return $excelmap\n}","function excel:get-workbook(\n$excel-map as map:map\n){\n   map:get($excel-map,\"xl\/workbook.xml\")\/ss:workbook\n}","function excel:get-sheet-by-name(\n    $excel-map as map:map, \n    $sheetname as xs:string \n) (:as element(ss:worksheet)?:)\n{ \n let $sheet-ref := map:get($excel-map,\"xl\/workbook.xml\")\/ss:workbook\/ss:sheets\/ss:sheet[@name eq $sheetname]\n let $rels-ptr  := map:get($excel-map,\"xl\/_rels\/workbook.xml.rels\")\/rel:Relationships\/rel:Relationship[\n    @Type eq $WORKSHEET-REL-TYPE and\n    @Id eq $sheet-ref\/@rel2:id\n ]\/@Target\n return \n    map:get($excel-map,fn:concat(\"xl\/\",$rels-ptr))\/ss:worksheet\n}","function excel:get-sheet-column-names(\n$sheet as element(ss:worksheet),\n$shared-strings as element(ss:sst)\n) {\n    excel:get-sheet-column-names($sheet,$shared-strings,1)\n}","function excel:shared-strings-map($excel-map as map:map) {\n  let $ss := excel:shared-strings($excel-map)\n  let $map := map:map()\n  let $_ := \n     for $s at $pos in $ss\/ss:si\n     return \n       map:put($map,fn:string($pos),fn:data($s\/ss:t))\n  return $map\n}","function excel:shared-strings(\n    $excel-map as map:map\n) {\n      let $ss-key := map:keys($excel-map)[fn:contains(.,\"sharedStrings\")]\n      return \n         map:get($excel-map,$ss-key)\/element()\n}"]},{"name":"declare function parameter types", "level":"warn", "occurrences":"1", "source":["function excel:load($excel){\n    let $excelmap := map:map()\n    \n\tlet $parts := ooxml:package-parts($excel)\n\tlet $_ :=\n\t    for $uri at $pos in ooxml:package-uris($excel)\n\t        let $content :=  fn:subsequence($parts,$pos,1)\n    \t    return\n    \t        if (fn:contains($uri,'.xml'))\n    \t        then (map:put($excelmap,$uri,$content))\n    \t        else ()\n\n     return $excelmap\n}"]},{"name":"avoid using descendant-or-self axis (\"\/\/\") where possible", "level":"info", "occurrences":"1", "source":["function excel:normalize-cell(\n\t$cells          as element(ss:c)*,\n\t$shared-strings as element(ss:sst)?\n) as element(ss:c)*\n{ \n    for $c at $pos in $cells\n    let $value :=\n        if ( $c\/@t=\"s\" ) then\n\t\t\tlet $shared-string :=\n\t\t\t\t$shared-strings\/ss:si[ fn:data($c\/ss:v) + 1 ]\/ss:t\n\t\t\treturn\n\t\t\t\tif ($shared-string) then\n\t\t\t\t\t$shared-string\n\t\t\t\telse\n\t\t\t\t\t(:fn:error(xs:QName(\"excel:missingstr\"), fn:concat(\"Shared string missing for cell \", $pos)):)\n\t\t\t\t\t()\n        else\n\t\t\t$c\/\/text()\n\treturn\n\t\t(: use fn:string() to account for empty cells, makes sure count\n\t\t : of return strings always equals count of input cells\n\t\t :)\n\t\t<ss:c t=\"inlineStr\">\n\t\t  { $c\/@*[fn:local-name(.) ne \"t\"] }\n\t\t  <ss:is>\n        <ss:v>{$value}<\/ss:v>\n      <\/ss:is>\n    <\/ss:c>\n}"]},{"name":"avoid nesting FLWOR expressions more than one level deep", "level":"warn", "occurrences":"2", "source":["function excel:replace-parts($excel as node(), $part-uris as xs:string*, $parts as node()*) as node() {\n\tlet $uris :=\n\t\tooxml:package-uris($excel)\n\tlet $new-parts :=\n\t\tfor $part at $pos in ooxml:package-parts($excel)\n\t\tlet $uri := $uris[$pos]\n\t\treturn\n\t\t\tif ($uri = $part-uris) then\n\t\t\t\tlet $index := fn:index-of($part-uris, $uri)\n\t\t\t\treturn\n\t\t\t\t\t$parts[$index]\n\t\t\telse\n\t\t\t\t$part\n\tlet $manifest :=\n\t\t<zip:parts>{\n\t\t\tfor $uri in $uris\n\t\t\treturn\n\t\t\t\t<zip:part>{$uri}<\/zip:part>\n\t\t}<\/zip:parts>\n    let $add := \n        for $uri at $pos in $part-uris\n        return \n          if($uri = $uris) then ()\n          else \n            (xdmp:set($new-parts,($new-parts,$parts[$pos])),\n             xdmp:set($manifest,\n              <zip:parts>{\n                $manifest\/*,\n                <zip:part>{$uri}<\/zip:part> \n              }<\/zip:parts>)\n           )\n\treturn \n\t\txdmp:zip-create($manifest, $new-parts)\n}","function excel:map-row-cells-to-elements-map-2(\n  $row as element(ss:row)?, \n  $column-names as map:map, \n  $shared-strings as map:map\n) as element()* {\n  let $cells := excel:get-row-cells($row)\n  let $last-column := get-last-column-index($column-names)\n  let $row-number := $row\/@r\n  return\n\t  for $column-name in map:keys($column-names)\n      let $col := map:get($column-names, $column-name)\n      let $cell-ref := $col || $row-number\n      let $pos := excel:get-character-position($col)\n      let $value :=\n      for $cell in $cells[1 to $last-column]\n      \tlet $value := fn:normalize-space(fn:translate(excel:cell-values($cell, $shared-strings), '&#160;', ' '))\n        where $cell\/@r = $cell-ref\n        return $value\n\n      order by $pos\n    \treturn\n    \t\telement field { \n    \t\t  attribute columnName { $column-name },\n    \t\t  attribute row { $row-number },\n    \t\t  attribute col { $pos },\n    \t\t\t$value\n  \t\t}\n}"]}]},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import\\plugins\\import-ascii-lib.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 105, column 1\n...declare private function get-del..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import\\plugins\\import-xlsx-lib.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 61, column 1\n...declare private function map-row..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\import\\plugins\\spreadsheet-ml-support2.xqy", "error":"lexical analysis failed\nwhile expecting '(:'\nafter successfully scanning 1 characters at line 195, column 12\n...()\n{\n    let $ws-count := fn:cou..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\test-import-large-files.xqy", "rule":[{"name":"declare function return type", "level":"warn", "occurrences":"3", "source":["function setup()\n{\n  setup:setup($test-collection)\n}","function teardown()\n{\n  setup:teardown($test-collection)\n}","function import-datasource()\n{\n  let $_ := elapsedtime:elapsed-time(\"*** START ***\")\n  let $doc := setup:get-binary-file(\"large-2.xlsx\")\n  let $_ := elapsedtime:elapsed-time(\"xdmp:external-binary\")\n  let $template := \n    <template xmlns=\"http:\/\/marklogic.com\/metadata\/template\">\n      <uuid>large-1<\/uuid>\n      <id>large-1<\/id>\n      <namespace-uri>http:\/\/marklogic.com\/episode<\/namespace-uri>\n      <class>9ee78be1-4e96-d0d7-3ada-f6377dde6c2a26a9eea9<\/class>\n      <data-type>xlsx<\/data-type>\n      <sheet>LARGE-1<\/sheet>\n      <mappings>\n        <mapping>\n          <source key=\"true\">ID<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>7824b352-f80d-4a49-1582-8db5a17d7d71e074a323<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>ASSET_NAME<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>d8dad0db-951a-d5a9-61e7-5ac617a0d262214348b9<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>PAC_PROVIDER<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>62130c90-3b99-f7fd-1bc4-c28b75e988466fc8d3e5<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>PAC_PRODUCT<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>a35c79aa-8eb6-7d4a-7869-9e2035abaa435d74b0fb<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>PAC_ASSET_NAME<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>4b5c03d4-1fb9-8e98-81a5-5966683bba217f315f4e<\/property>\n          <\/destination>\n        <\/mapping>\n      <\/mappings>\n    <\/template>\n\n  let $batch := setup:get-batch()\n  let $_ := elapsedtime:elapsed-time(\"setup:get-batch\")\n  let $array := import:convert-source-to-dataset($doc, $template, setup:get-default-mappings(), setup:get-default-options($test-collection))\n  let $_ := elapsedtime:elapsed-time(\"import:convert-source-to-dataset\")\n  let $dataset := import:consolidate-dataset($batch, $array, $template, setup:get-default-mappings(), setup:get-default-options($test-collection))\n  let $_ := elapsedtime:elapsed-time(\"import:consolidate-dataset\")\n  let $_ := import:import-datasource($batch, $dataset, $template, setup:get-default-mappings(), setup:get-default-options($test-collection))\n  let $_ := elapsedtime:elapsed-time(\"import:import-datasource\")\n(:  let $_ := xdmp:document-insert(\"\/log\/\" || $batch, json:array-values(elapsedtime:get-time()), (), $test-collection):)\n  let $_ := xdmp:document-insert(\"\/log\/\" || $batch, <elapsedtime:log>{json:array-values(elapsedtime:get-time())}<\/elapsedtime:log>, xdmp:default-permissions(), $test-collection)\n  return ()\n}"]},{"name":"avoid long functions", "level":"warn", "occurrences":"1", "source":["function import-datasource()\n{\n  let $_ := elapsedtime:elapsed-time(\"*** START ***\")\n  let $doc := setup:get-binary-file(\"large-2.xlsx\")\n  let $_ := elapsedtime:elapsed-time(\"xdmp:external-binary\")\n  let $template := \n    <template xmlns=\"http:\/\/marklogic.com\/metadata\/template\">\n      <uuid>large-1<\/uuid>\n      <id>large-1<\/id>\n      <namespace-uri>http:\/\/marklogic.com\/episode<\/namespace-uri>\n      <class>9ee78be1-4e96-d0d7-3ada-f6377dde6c2a26a9eea9<\/class>\n      <data-type>xlsx<\/data-type>\n      <sheet>LARGE-1<\/sheet>\n      <mappings>\n        <mapping>\n          <source key=\"true\">ID<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>7824b352-f80d-4a49-1582-8db5a17d7d71e074a323<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>ASSET_NAME<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>d8dad0db-951a-d5a9-61e7-5ac617a0d262214348b9<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>PAC_PROVIDER<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>62130c90-3b99-f7fd-1bc4-c28b75e988466fc8d3e5<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>PAC_PRODUCT<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>a35c79aa-8eb6-7d4a-7869-9e2035abaa435d74b0fb<\/property>\n          <\/destination>\n        <\/mapping>\n        <mapping>\n          <source>PAC_ASSET_NAME<\/source>\n          <destination>\n            <propertyGroup>5a855dcf-faa9-a59d-c785-f89935e63de4835057c4<\/propertyGroup>\n            <property>4b5c03d4-1fb9-8e98-81a5-5966683bba217f315f4e<\/property>\n          <\/destination>\n        <\/mapping>\n      <\/mappings>\n    <\/template>\n\n  let $batch := setup:get-batch()\n  let $_ := elapsedtime:elapsed-time(\"setup:get-batch\")\n  let $array := import:convert-source-to-dataset($doc, $template, setup:get-default-mappings(), setup:get-default-options($test-collection))\n  let $_ := elapsedtime:elapsed-time(\"import:convert-source-to-dataset\")\n  let $dataset := import:consolidate-dataset($batch, $array, $template, setup:get-default-mappings(), setup:get-default-options($test-collection))\n  let $_ := elapsedtime:elapsed-time(\"import:consolidate-dataset\")\n  let $_ := import:import-datasource($batch, $dataset, $template, setup:get-default-mappings(), setup:get-default-options($test-collection))\n  let $_ := elapsedtime:elapsed-time(\"import:import-datasource\")\n(:  let $_ := xdmp:document-insert(\"\/log\/\" || $batch, json:array-values(elapsedtime:get-time()), (), $test-collection):)\n  let $_ := xdmp:document-insert(\"\/log\/\" || $batch, <elapsedtime:log>{json:array-values(elapsedtime:get-time())}<\/elapsedtime:log>, xdmp:default-permissions(), $test-collection)\n  return ()\n}"]}]},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\test-import-lib.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 256, column 1\n...declare private function get-add..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\test-module-loader.xqy", "error":"lexical analysis failed\nwhile expecting '(:'\nafter successfully scanning 1 characters at line 29, column 114\n...($ex) { $ex }\n  let $plugins2 :=..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\test-updated-entities.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 67, column 1\n...declare private function _setup-..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\test-validate-template.xqy", "error":"lexical analysis failed\nwhile expecting '(:'\nafter successfully scanning 1 characters at line 67, column 67\n...($ex) { $ex }\n  return \n  (\n    ..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\plugins\\test-plugin-1.xqy"},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\plugins\\test-plugin-2.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 13, column 1\n...declare private function get-hel..."},{"src":"C:\\Users\\rlouapre\\Projects\\ml\\marklogic_amc-git\\src\\app\\lib\\test\\setup\\setup.xqy", "error":"syntax error, found 'declare'\nwhile expecting EOF\nafter successfully scanning 7 characters at line 9, column 1\n...declare private variable $USE-MO..."}]}}